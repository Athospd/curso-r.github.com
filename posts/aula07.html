<!DOCTYPE html>
<html>
<head>
  <title>Aula 07 - Modelando</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="" />
  <meta name="author" content="julio.trecenti@gmail.com,curso-r,Curso,R">
  <link rel="shortcut icon" href="/assets/img/curso_r2.jpg">
  <link rel="alternate" type="application/rss+xml" href="">
  <link href="../libraries/frameworks/purus/css/bootstrap.min.css" rel="stylesheet" />
  <link href="../libraries/frameworks/purus/css/bootstrap-responsive.min.css" rel="stylesheet" />
  <link href="../libraries/frameworks/purus/css/main.css" rel="stylesheet" />
  <link href="../libraries/highlighters/prettify/css/twitter-bootstrap.css" rel="stylesheet">
  <!-- IE6-8 support of HTML5 elements -->
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href='http://fonts.googleapis.com/css?family=Raleway:400,600,200,800' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Droid+Sans' rel='stylesheet' type='text/css'>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
    ga('create', 'UA-58167912-1', 'auto');
    ga('send', 'pageview');
  
  </script>
    <style>
	  #sidebar .sidebar-nav .info h3 a:hover, a:hover { color: #01A9DB; }
	  #sidebar .sidebar-nav #avatar img, #sidebar .sidebar-nav ul#links li.active a { border-color: #01A9DB; }
	  #sidebar .sidebar-nav ul#links li a:hover { background: #01A9DB; }
    p {text-align: justify;}
  </style>
  <link rel="stylesheet" href = "../assets/css/custom.css">
<link rel="stylesheet" href = "../assets/css/ribbons.css">

</head>
<body>
	<div class="container-fluid">
		<div class="row-fluid">
			<div id="sidebar" class="span2">
			  <div class="sidebar-nav sidebar-nav-fixed">
			    <a href="https://github.com/ramnathv/poirot">
      <img style="position: absolute; top: 0; left: 100px; border: 0; height: 100px; z-index: 1;" 
        alt="Fork me on GitHub" 
        src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" >
    </a>
	  <div class="info">
				    <p id="avatar"><a href="#"><img alt="Title" src="http://curso-r.github.io/assets/img/curso_r2.jpg " /></a></p>
				    <h3><a href="/">Curso R </a></h3>
					  <p class="description">Do casual ao avançado</p>
					</div>
					<ul id="links">
			        <li><a href="http://curso-r.github.io/index.html">Home</a></li>
        <li><a href="http://curso-r.github.io/about.html">Sobre</a></li>
        <li><a href="http://curso-r.github.io/links.html">Links Úteis</a></li>
        <li><a href="http://curso-r.github.io/exercicios.html">Exercícios</a></li>
      
        <li><a href="http://github.com/curso-r" id="Github-link">Github</a></li>
                      
			    </ul>
				</div>
			</div>
						<div id="content" class='span10'>
				<div id="post-wrapper">
          <ol id="posts">
            <li class="post">
              <h3>
                <a href="#">Aula 07 - Modelando</a>
              </h3>
              <span>2015-02-02</span><br/>
               <a class='label label-success' href='posts/aula07.Rmd'>Source</a>
              
<p><a href="http://curso-r.github.io/slides/aula_07_apresentacao.html" target="_blank">Slides dessa aula</a></p>

<p><a href="http://curso-r.github.io/script/aula_07.R" target="_blank">Script dessa aula</a></p>

<h1>Regressão Linear e ANOVA</h1>

<p>O R tem todo o ferramentário necessário para fazer modelos lineares, a começar pelo modelo de regressão linear normal.</p>

<p>Para ilustrar, vamos utilizar a base de dados <code>mtcars</code> que vem no R.</p>

<p>Cada uma das 32 linhas da base <code>mtcars</code> representa um carro. A variável <code>mpg</code> é o consumo de combustível em milhas por galão (~3.76 Litros) e iremos tentar explicá-la pelas demais características dos veículos. </p>

<h2>Um pouco de descritiva</h2>

<h3>Univariada</h3>

<pre><code class="r"># os dados
head(mtcars)
</code></pre>

<pre><code>##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1
## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2
## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1
</code></pre>

<pre><code class="r"># banco de dados das variáveis contínuas no formato &quot;longo&quot;
mtcars_long &lt;- mtcars %&gt;%  
  select(mpg, disp:qsec) %&gt;%
  gather(var_continuas) 
</code></pre>

<pre><code>## Error in select(., mpg, disp:qsec): unused arguments (mpg, disp:qsec)
</code></pre>

<pre><code class="r"># medidas resumo para variáveis contínuas
mtcars_long %&gt;%
  group_by(var_continuas) %&gt;%
  summarise(&quot;N&quot; = n(),
            &quot;Missing&quot; = sum(is.na(value)),
            &quot;Media&quot; = mean(value),
            &quot;DesvPad&quot; = sd(value),
            &quot;Minimo&quot; = min(value),
            &quot;Q1&quot; = quantile(value, 0.25),
            &quot;Mediana&quot; = quantile(value, 0.50),
            &quot;Q3&quot; = quantile(value, 0.75),
            &quot;Maximo&quot; = max(value)) %&gt;%
  mutate_each(funs(round(.,1)), -var_continuas)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;mtcars_long&#39; not found
</code></pre>

<pre><code class="r"># boxplots
mtcars_long %&gt;%
  ggplot() +
  geom_boxplot(aes(x=1, y = value)) +
  facet_wrap(~var_continuas, scales = &quot;free&quot;) 
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;mtcars_long&#39; not found
</code></pre>

<pre><code class="r"># frequencias de variáveis categóricas
mtcars_freq &lt;- mtcars %&gt;%
  select(cyl, vs:carb) %&gt;%
  gather(vars_categoricas) %&gt;%
  rename(categoria = value) %&gt;%
  group_by(vars_categoricas, categoria) %&gt;%
  summarise(freq = n()) %&gt;%
  group_by(vars_categoricas) %&gt;%
  mutate(prop = freq/sum(freq),
         prop_txt = (prop*100) %&gt;% round(0) %&gt;% paste0(&quot;%&quot;))
</code></pre>

<pre><code>## Error in select(., cyl, vs:carb): unused arguments (cyl, vs:carb)
</code></pre>

<pre><code class="r">mtcars_freq
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;mtcars_freq&#39; not found
</code></pre>

<pre><code class="r"># Gráfico de barras
mtcars_freq %&gt;%
  ggplot() +
  geom_bar(aes(x=categoria, y = freq), position = &quot;dodge&quot;, stat = &quot;identity&quot;) +
  facet_wrap(~vars_categoricas, scales=&quot;free&quot;)  
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;mtcars_freq&#39; not found
</code></pre>

<h3>Versus <code>mpg</code></h3>

<pre><code class="r"># Matriz de correlação linear
mtcars %&gt;%  
  select(mpg, disp:qsec) %&gt;%
  cor %&gt;%
  round(2) 
</code></pre>

<pre><code>## Error in select(., mpg, disp:qsec): unused arguments (mpg, disp:qsec)
</code></pre>

<pre><code class="r"># Matriz de dispersão
pairs(mtcars %&gt;%  
  select(mpg, disp:qsec))
</code></pre>

<pre><code>## Error in select(., mpg, disp:qsec): unused arguments (mpg, disp:qsec)
</code></pre>

<h2>Regressão linear</h2>

<p>A função que ajusta modelo linear normal no R é <code>lm()</code>. Você especifica o banco de dados e a fórmula com as variáveis que você deseja associar.</p>

<pre><code class="r">ajuste &lt;- lm(resposta ~ explicativas, data = meus_dados)
</code></pre>

<p>O objeto <code>ajuste</code> contém todos os resultados e com a ajuda de alguns comandos, você extrai tudo o que é interessante.</p>

<p>Exemplo:</p>

<pre><code class="r">ajuste_lm &lt;- lm(mpg ~ wt, data = mtcars)

ajuste_lm
</code></pre>

<pre><code>## 
## Call:
## lm(formula = mpg ~ wt, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt  
##   37.285126    -5.344472
</code></pre>

<p>No código acima temos <code>mpg</code> explicado por <code>wt</code>. A saída do <code>lm()</code> mostra qual foi a chamada do modelo e os coeficientes ajustados. Como visto na análise descritiva, há uma clara associação linear e negativa entre as variáveis, justificando o parâmetro negativo <code>wt = -5.344</code>. A função <code>coeficients()</code> ou <code>coef()</code> nos fornece os coeficientes ajustados.</p>

<p>Gráfico da reta ajustada:</p>

<pre><code class="r"># extrai os coeficientes ajustados
coeficientes &lt;- coef(ajuste_lm)

ggplot(mtcars) +
  geom_point(aes(x = wt, y = mpg)) +
  geom_abline(intercept = coeficientes[1], slope = coeficientes[2])
</code></pre>

<p><img src="assets/fig/unnamed-chunk-6-1.png" alt="plot of chunk unnamed-chunk-6"> </p>

<p><strong>summary()</strong></p>

<p>A função <code>summary()</code> é uma função genérica que geralmente devolve um resumo de informações úteis de praticamente qualquer classe de objetos. Para objetos <code>lm()</code> ela devolve:</p>

<ol>
<li>Chamada do modelo</li>
<li>Medidas resumo dos resíduos</li>
<li>Tabela de coeficientes, desvios padrão e testes T para hipótese nula de parâmetros iguais a zero.</li>
<li>Média dos quadrados do resíduo e os respectivos graus de liberdade; \(R^2\) e \(R^2\) ajustado da regressão; Estatística F para qualidade do ajuste (comparação com o modelo com apenas o intercepto).</li>
</ol>

<pre><code class="r">summary(ajuste_lm)
</code></pre>

<p><img src="assets/fig/summary_lm.png" alt="summary lm"></p>

<p><strong>plot()</strong></p>

<p>A função <code>plot()</code> constrói gráficos úteis para diagnóstico do modelo.</p>

<pre><code class="r"># opção para mostrar 4 gráficos em uma mesma figura
par(mfrow = c(2,2))

# gráficos de diagnóstico do modelo ajuste_lm
plot(ajuste_lm)
</code></pre>

<p><img src="assets/fig/unnamed-chunk-8-1.png" alt="plot of chunk unnamed-chunk-8"> </p>

<pre><code class="r"># retorna ao normal
par(mfrow = c(1,1))
</code></pre>

<p><strong>anova()</strong></p>

<p>Uma parte importante da modelagem é a redução de modelos. A função <code>anova()</code> compara dois (ou mais) modelos encaixados por meio da estatística F (por padrão), especialmente indicadas para modelos lineares normais. Caso seja passada apenas um ajuste à função, ela devolve a tabela de ANOVA (termos testados sequencialmente).</p>

<pre><code class="r"># modelo nulo, com apenas o intercepto
ajuste_lm_nulo &lt;- lm(mpg ~ 1, data = mtcars)

# modelo com wt e cyl
ajuste_lm2 &lt;- lm(mpg ~ wt + factor(cyl), data = mtcars)

# compara o modelo com wt com o modelo nulo
anova(ajuste_lm_nulo, ajuste_lm)
</code></pre>

<pre><code>## Analysis of Variance Table
## 
## Model 1: mpg ~ 1
## Model 2: mpg ~ wt
##   Res.Df        RSS Df Sum of Sq        F          Pr(&gt;F)    
## 1     31 1126.04719                                          
## 2     30  278.32194  1 847.72525 91.37533 0.0000000001294 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
</code></pre>

<pre><code class="r"># Tabela de ANOVA, testa os termos sequencialmente
anova(ajuste_lm2)
</code></pre>

<pre><code>## Analysis of Variance Table
## 
## Response: mpg
##             Df    Sum Sq   Mean Sq   F value            Pr(&gt;F)    
## wt           1 847.72525 847.72525 129.66504 0.000000000005079 ***
## factor(cyl)  2  95.26329  47.63164   7.28557         0.0028353 ** 
## Residuals   28 183.05865   6.53781                                
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
</code></pre>

<p>A o valor-p = 0.001064 indica que o modelo com <code>wt + cyl</code> trás melhorias significantes no poder explicativo do modelo quando comparado ao modelo com apenas <code>wt</code>. </p>

<p><strong>demais comandos</strong></p>

<p>Outros comandos úteis são:</p>

<table><thead>
<tr>
<th align="center">Função</th>
<th align="center">Descrição</th>
</tr>
</thead><tbody>
<tr>
<td align="center">confint()</td>
<td align="center">Intervalo de confiança para os parâmetros</td>
</tr>
<tr>
<td align="center">resid()</td>
<td align="center">Resíduos do modelo</td>
</tr>
<tr>
<td align="center">fitted()</td>
<td align="center">Valores ajustados</td>
</tr>
<tr>
<td align="center">AIC()</td>
<td align="center">Critério de informação de Akaike</td>
</tr>
<tr>
<td align="center">model.matrix()</td>
<td align="center">Matriz de planejamento (matriz X) do modelo</td>
</tr>
<tr>
<td align="center">linearHypotesis()</td>
<td align="center">Teste de combinações lineares de parâmetros</td>
</tr>
<tr>
<td align="center">vcov()</td>
<td align="center">Matriz de variância-covariância dos parâmetros</td>
</tr>
</tbody></table>

<h2>Fórmulas</h2>

<p>Objetos de classe <code>formula</code> possuem sintaxe muito conveniente para especificar o modelo estatístico que desejamos ajustar. O símbolo que define esses objetos é o <code>~</code>.</p>

<p>Estrutura:</p>

<pre><code class="r">ajuste &lt;- lm(resposta ~ explicativas)
</code></pre>

<p>Então se o objetivo fosse ajustar o modelo</p>

<p>\[
Y_i = \beta_0 + \beta_1X_i + \epsilon_i,
\]</p>

<p>passaríamos ao R a seguinte fórmula</p>

<pre><code class="r">ajuste &lt;- lm(Y ~ X)
</code></pre>

<p>Para incorporar mais variáveis usamos o símbolo <code>+</code>. O modelo</p>

<p>\[
Y_i = \beta_0 + \beta_1X_i + \beta_2Z_i + \epsilon_i,
\]</p>

<p>ficaria traduzido como</p>

<pre><code class="r">ajuste &lt;- lm(Y ~ X + Z)
</code></pre>

<p>Utilizamos o símbolo <code>*</code> para introduzir os componentes de interação, além dos componentes aditivos.</p>

<pre><code class="r">ajuste &lt;- lm(Y ~ X * Z)
</code></pre>

<p>Teoricamente teríamos, para Z <strong>contínua</strong>, o modelo de regressão</p>

<p>\[
Y_i = \beta_0 + \beta_1X_i + \beta_2Z_i + \beta_3X_i*Z_i + \epsilon_i,
\]</p>

<p>Ou, para Z <strong>categórica</strong>, o modelo de ANCOVA</p>

<p>\[
Y_{ij} = \alpha_j + \beta_jX_{ij} + \epsilon_{ij},
\]</p>

<p>O operador <code>:</code> faz com que apenas o componente de interação seja incluído no modelo. Para ilustrar, observe que o modelo</p>

<pre><code class="r">ajuste &lt;- lm(Y ~ X * Z)
</code></pre>

<p>é a mesma coisa que</p>

<pre><code class="r">ajuste &lt;- lm(Y ~ X + Z + X:Z)
</code></pre>

<p>Os operadores aritméticos exercem função diferente em fórmulas. O sinal de <code>+</code> no exemplo induziu em um modelo aditivo em vez de somar X com Z. Para fazer com que eles assumam seus significados aritméticos temos que utilizar a função <code>I()</code>. Exemplo:</p>

<pre><code class="r">ajuste &lt;- lm(Y ~ I(X + Z))
</code></pre>

<p>Agora sim o componente <code>I(X + Z)</code> representa a soma de X com Z. Outros exemplos: <code>I(X^2)</code>, <code>I(log(X + 1))</code>, <code>I(sqrt(X+Z*5))</code>.</p>

<p><strong>Tabela de simbolos para utilizar em fórmulas</strong></p>

<table><thead>
<tr>
<th align="center">Símbolo</th>
</tr>
</thead><tbody>
<tr>
<td align="center">+ X</td>
</tr>
<tr>
<td align="center">- X</td>
</tr>
<tr>
<td align="center">X * Z</td>
</tr>
<tr>
<td align="center">X : Z</td>
</tr>
<tr>
<td align="center">(X + Z + W)<sup>2</sup></td>
</tr>
<tr>
<td align="center">I(X + Z)</td>
</tr>
<tr>
<td align="center">X - 1</td>
</tr>
<tr>
<td align="center">.</td>
</tr>
</tbody></table>

<p>Table: Table continues below</p>

<table><thead>
<tr>
<th align="center">Descrição</th>
</tr>
</thead><tbody>
<tr>
<td align="center">inclui a variável X</td>
</tr>
<tr>
<td align="center">retira a variável X</td>
</tr>
<tr>
<td align="center">inclui X, Z e a interação entre elas</td>
</tr>
<tr>
<td align="center">inclui apenas o componente de interação entre X e Z</td>
</tr>
<tr>
<td align="center">inclui X, Z, W e as interações 2 a 2</td>
</tr>
<tr>
<td align="center">Função identidade. Inclui uma variável construída pela soma de X com Z</td>
</tr>
<tr>
<td align="center">Remove o intercepto (regressão passando pela origem)</td>
</tr>
<tr>
<td align="center">O ponto representa &#39;todas as demais variáveis&#39;</td>
</tr>
</tbody></table>

<h2>Seleção de variáveis</h2>

<h3>linearHypothesis</h3>

<p>Frequentemente temos interesse em saber se parâmetros são diferentes de zero ou se são diferentes entre si. Para isto, costumamos efetuar testes do tipo Wald para combinações lineares dos parâmetros.</p>

<p>Para este fim, a função <code>linearHypothesis()</code> do pacote <code>car</code> faz o trabalho.</p>

<pre><code class="r">library(car)

linearHypothesis(ajuste_lm, c(0,1))
</code></pre>

<pre><code>## Linear hypothesis test
## 
## Hypothesis:
## wt = 0
## 
## Model 1: restricted model
## Model 2: mpg ~ wt
## 
##   Res.Df        RSS Df Sum of Sq        F          Pr(&gt;F)    
## 1     31 1126.04719                                          
## 2     30  278.32194  1 847.72525 91.37533 0.0000000001294 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
</code></pre>

<h3>stepwise</h3>

<p>Stepwise no R se faz com as funções <code>step()</code> do pacote <code>stats</code> ou <code>stepAIC()</code> do pacote <code>MASS</code>. Escolher entre <code>forward</code>, <code>backward</code> ou <code>both</code> (ambos) basta passar um desses nomes ao parâmetro <code>direction</code> da função.</p>

<pre><code class="r"># modelo aditivo completo
ajuste_lm_completo &lt;- lm(mpg ~ ., data = mtcars)

# modelo forward
step(ajuste_lm_completo, direction = &quot;forward&quot;)
</code></pre>

<pre><code>## Start:  AIC=70.9
## mpg ~ cyl + disp + hp + drat + wt + qsec + vs + am + gear + carb
</code></pre>

<pre><code>## 
## Call:
## lm(formula = mpg ~ cyl + disp + hp + drat + wt + qsec + vs + 
##     am + gear + carb, data = mtcars)
## 
## Coefficients:
## (Intercept)          cyl         disp           hp         drat           wt         qsec           vs           am         gear         carb  
## 12.30337416  -0.11144048   0.01333524  -0.02148212   0.78711097  -3.71530393   0.82104075   0.31776281   2.52022689   0.65541302  -0.19941925
</code></pre>

<pre><code class="r"># modelo backward
step(ajuste_lm_completo, direction = &quot;backward&quot;)
</code></pre>

<pre><code>## Start:  AIC=70.9
## mpg ~ cyl + disp + hp + drat + wt + qsec + vs + am + gear + carb
## 
##        Df  Sum of Sq       RSS       AIC
## - cyl   1  0.0798712 147.57430 68.915068
## - vs    1  0.1601257 147.65456 68.932466
## - carb  1  0.4066688 147.90110 68.985853
## - gear  1  1.3530555 148.84749 69.189961
## - drat  1  1.6270263 149.12146 69.248807
## - disp  1  3.9166671 151.41110 69.736407
## - hp    1  6.8399100 154.33434 70.348332
## - qsec  1  8.8641160 156.35855 70.765307
## &lt;none&gt;               147.49443 70.897744
## - am    1 10.5466514 158.04108 71.107811
## - wt    1 27.0143855 174.50881 74.279659
## 
## Step:  AIC=68.92
## mpg ~ disp + hp + drat + wt + qsec + vs + am + gear + carb
## 
##        Df  Sum of Sq       RSS       AIC
## - vs    1  0.2685228 147.84282 66.973242
## - carb  1  0.5201418 148.09444 67.027657
## - gear  1  1.8211468 149.39545 67.307549
## - drat  1  1.9826232 149.55692 67.342118
## - disp  1  3.9009393 151.47524 67.749961
## - hp    1  7.3631648 154.93747 68.473142
## &lt;none&gt;               147.57430 68.915068
## - qsec  1 10.0932561 157.66756 69.032091
## - am    1 11.8359442 159.41025 69.383844
## - wt    1 27.0280449 174.60235 72.296806
## 
## Step:  AIC=66.97
## mpg ~ disp + hp + drat + wt + qsec + am + gear + carb
## 
##        Df  Sum of Sq       RSS       AIC
## - carb  1  0.6854608 148.52829 65.121264
## - gear  1  2.1436837 149.98651 65.433902
## - drat  1  2.2138988 150.05672 65.448879
## - disp  1  3.6466512 151.48947 65.752968
## - hp    1  7.1059603 154.94878 66.475480
## &lt;none&gt;               147.84282 66.973242
## - am    1 11.5693808 159.41221 67.384238
## - qsec  1 15.6830478 163.52587 68.199530
## - wt    1 27.3799421 175.22277 70.410311
## 
## Step:  AIC=65.12
## mpg ~ disp + hp + drat + wt + qsec + am + gear
## 
##        Df Sum of Sq       RSS       AIC
## - gear  1  1.564971 150.09325 63.456669
## - drat  1  1.932127 150.46041 63.534851
## &lt;none&gt;              148.52829 65.121264
## - disp  1 10.110262 158.63855 65.228558
## - am    1 12.323215 160.85150 65.671862
## - hp    1 14.825636 163.35392 66.165864
## - qsec  1 26.408059 174.93634 68.357960
## - wt    1 69.126924 217.65521 75.349641
## 
## Step:  AIC=63.46
## mpg ~ disp + hp + drat + wt + qsec + am
## 
##        Df Sum of Sq       RSS       AIC
## - drat  1  3.344551 153.43781 62.161901
## - disp  1  8.545358 158.63861 63.228571
## &lt;none&gt;              150.09325 63.456669
## - hp    1 13.284651 163.37791 64.170562
## - am    1 20.035878 170.12913 65.466299
## - qsec  1 25.574406 175.66766 66.491457
## - wt    1 67.571960 217.66522 73.351113
## 
## Step:  AIC=62.16
## mpg ~ disp + hp + wt + qsec + am
## 
##        Df Sum of Sq       RSS       AIC
## - disp  1  6.628654 160.06646 61.515302
## &lt;none&gt;              153.43781 62.161901
## - hp    1 12.572053 166.00986 62.681961
## - qsec  1 26.469795 179.90760 65.254640
## - am    1 32.197518 185.63532 66.257543
## - wt    1 69.043043 222.48085 72.051364
## 
## Step:  AIC=61.52
## mpg ~ hp + wt + qsec + am
## 
##        Df Sum of Sq       RSS       AIC
## - hp    1  9.219469 169.28593 61.307305
## &lt;none&gt;              160.06646 61.515302
## - qsec  1 20.224611 180.29107 63.322775
## - am    1 25.992837 186.05930 64.330545
## - wt    1 78.493773 238.56023 72.284350
## 
## Step:  AIC=61.31
## mpg ~ wt + qsec + am
## 
##        Df  Sum of Sq       RSS       AIC
## &lt;none&gt;               169.28593 61.307305
## - am    1  26.177702 195.46363 63.908430
## - qsec  1 109.033768 278.31970 75.217105
## - wt    1 183.347261 352.63319 82.790160
</code></pre>

<pre><code>## 
## Call:
## lm(formula = mpg ~ wt + qsec + am, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt         qsec           am  
##    9.617781    -3.916504     1.225886     2.935837
</code></pre>

<pre><code class="r"># modelo both
step(ajuste_lm_completo, direction = &quot;both&quot;)
</code></pre>

<pre><code>## Start:  AIC=70.9
## mpg ~ cyl + disp + hp + drat + wt + qsec + vs + am + gear + carb
## 
##        Df  Sum of Sq       RSS       AIC
## - cyl   1  0.0798712 147.57430 68.915068
## - vs    1  0.1601257 147.65456 68.932466
## - carb  1  0.4066688 147.90110 68.985853
## - gear  1  1.3530555 148.84749 69.189961
## - drat  1  1.6270263 149.12146 69.248807
## - disp  1  3.9166671 151.41110 69.736407
## - hp    1  6.8399100 154.33434 70.348332
## - qsec  1  8.8641160 156.35855 70.765307
## &lt;none&gt;               147.49443 70.897744
## - am    1 10.5466514 158.04108 71.107811
## - wt    1 27.0143855 174.50881 74.279659
## 
## Step:  AIC=68.92
## mpg ~ disp + hp + drat + wt + qsec + vs + am + gear + carb
## 
##        Df  Sum of Sq       RSS       AIC
## - vs    1  0.2685228 147.84282 66.973242
## - carb  1  0.5201418 148.09444 67.027657
## - gear  1  1.8211468 149.39545 67.307549
## - drat  1  1.9826232 149.55692 67.342118
## - disp  1  3.9009393 151.47524 67.749961
## - hp    1  7.3631648 154.93747 68.473142
## &lt;none&gt;               147.57430 68.915068
## - qsec  1 10.0932561 157.66756 69.032091
## - am    1 11.8359442 159.41025 69.383844
## + cyl   1  0.0798712 147.49443 70.897744
## - wt    1 27.0280449 174.60235 72.296806
## 
## Step:  AIC=66.97
## mpg ~ disp + hp + drat + wt + qsec + am + gear + carb
## 
##        Df  Sum of Sq       RSS       AIC
## - carb  1  0.6854608 148.52829 65.121264
## - gear  1  2.1436837 149.98651 65.433902
## - drat  1  2.2138988 150.05672 65.448879
## - disp  1  3.6466512 151.48947 65.752968
## - hp    1  7.1059603 154.94878 66.475480
## &lt;none&gt;               147.84282 66.973242
## - am    1 11.5693808 159.41221 67.384238
## - qsec  1 15.6830478 163.52587 68.199530
## + vs    1  0.2685228 147.57430 68.915068
## + cyl   1  0.1882683 147.65456 68.932466
## - wt    1 27.3799421 175.22277 70.410311
## 
## Step:  AIC=65.12
## mpg ~ disp + hp + drat + wt + qsec + am + gear
## 
##        Df Sum of Sq       RSS       AIC
## - gear  1  1.564971 150.09325 63.456669
## - drat  1  1.932127 150.46041 63.534851
## &lt;none&gt;              148.52829 65.121264
## - disp  1 10.110262 158.63855 65.228558
## - am    1 12.323215 160.85150 65.671862
## - hp    1 14.825636 163.35392 66.165864
## + carb  1  0.685461 147.84282 66.973242
## + vs    1  0.433842 148.09444 67.027657
## + cyl   1  0.414429 148.11386 67.031852
## - qsec  1 26.408059 174.93634 68.357960
## - wt    1 69.126924 217.65521 75.349641
## 
## Step:  AIC=63.46
## mpg ~ disp + hp + drat + wt + qsec + am
## 
##        Df Sum of Sq       RSS       AIC
## - drat  1  3.344551 153.43781 62.161901
## - disp  1  8.545358 158.63861 63.228571
## &lt;none&gt;              150.09325 63.456669
## - hp    1 13.284651 163.37791 64.170562
## + gear  1  1.564971 148.52829 65.121264
## + cyl   1  1.003399 149.08986 65.242025
## + vs    1  0.645486 149.44777 65.318754
## + carb  1  0.106748 149.98651 65.433902
## - am    1 20.035878 170.12913 65.466299
## - qsec  1 25.574406 175.66766 66.491457
## - wt    1 67.571960 217.66522 73.351113
## 
## Step:  AIC=62.16
## mpg ~ disp + hp + wt + qsec + am
## 
##        Df Sum of Sq       RSS       AIC
## - disp  1  6.628654 160.06646 61.515302
## &lt;none&gt;              153.43781 62.161901
## - hp    1 12.572053 166.00986 62.681961
## + drat  1  3.344551 150.09325 63.456669
## + gear  1  2.977394 150.46041 63.534851
## + cyl   1  2.446693 150.99111 63.647523
## + vs    1  1.120807 152.31700 63.927295
## + carb  1  0.011427 153.42638 64.159518
## - qsec  1 26.469795 179.90760 65.254640
## - am    1 32.197518 185.63532 66.257543
## - wt    1 69.043043 222.48085 72.051364
## 
## Step:  AIC=61.52
## mpg ~ hp + wt + qsec + am
## 
##        Df Sum of Sq       RSS       AIC
## - hp    1  9.219469 169.28593 61.307305
## &lt;none&gt;              160.06646 61.515302
## + disp  1  6.628654 153.43781 62.161901
## + carb  1  3.227190 156.83927 62.863540
## + drat  1  1.427847 158.63861 63.228571
## - qsec  1 20.224611 180.29107 63.322775
## + cyl   1  0.248979 159.81748 63.465489
## + vs    1  0.248550 159.81791 63.465574
## + gear  1  0.171123 159.89534 63.481074
## - am    1 25.992837 186.05930 64.330545
## - wt    1 78.493773 238.56023 72.284350
## 
## Step:  AIC=61.31
## mpg ~ wt + qsec + am
## 
##        Df  Sum of Sq       RSS       AIC
## &lt;none&gt;               169.28593 61.307305
## + hp    1   9.219469 160.06646 61.515302
## + carb  1   8.035944 161.24999 61.751039
## + disp  1   3.276070 166.00986 62.681961
## + cyl   1   1.501058 167.78487 63.022295
## + drat  1   1.399618 167.88631 63.041636
## + gear  1   0.122716 169.16321 63.284099
## + vs    1   0.000466 169.28546 63.307217
## - am    1  26.177702 195.46363 63.908430
## - qsec  1 109.033768 278.31970 75.217105
## - wt    1 183.347261 352.63319 82.790160
</code></pre>

<pre><code>## 
## Call:
## lm(formula = mpg ~ wt + qsec + am, data = mtcars)
## 
## Coefficients:
## (Intercept)           wt         qsec           am  
##    9.617781    -3.916504     1.225886     2.935837
</code></pre>

<h2>Regressão Linear Generalizada</h2>
<p>A regressão linear normal pode ser inadequada quando a distribuição de \(Y_i\) é assimétrica, representa
dados de contagens ou então dados binários. Para lidar com esse problema, McCulagh e Nelder estenderam
a família de distribuições para ajuste da regressão para distribuições da <em>família exponencial</em>. Tal
família inclui as distribuições <code>normal</code>, <code>poisson</code>, <code>gama</code>, <code>normal inversa</code> e <code>binomial</code> (incluindo
<code>bernoulli</code>), entre outras. Também existe uma forma de adaptar os MLG para a distribuição <code>binomial negativa</code>.</p>

<p>A definição dos MLG é dada por</p>

<p>\[
Y_i \sim F(\mu_i, \phi)
\]</p>

<p>\[
\mu_i = g^{-1}(\alpha + \beta_1 x_{i1} + \beta_p x_{ip})
\]</p>

<p>O parâmetro \(\phi\) é o parâmetro de precisão (inverso do parâmetro de dispersão) e \(g\) é a <em>função de ligação</em>, que geralmente tem o papel de jogar o intervalo de vação de \(\mu_i\) (espaço paramétrico) no intervalo \((-\inf, \inf)\).</p>

<p>Para ajustar um modelo linear generalizado, basta utilizar a função <code>glm</code> e informar, além da fórmula, a família de distribuições da resposta.</p>

<h3>Famílias de distribuições</h3>

<table><thead>
<tr>
<th align="center">Family</th>
<th align="center">Link</th>
</tr>
</thead><tbody>
<tr>
<td align="center">gaussian</td>
<td align="center">identity</td>
</tr>
<tr>
<td align="center">binomial</td>
<td align="center">logit, probit, cloglog</td>
</tr>
<tr>
<td align="center">poisson</td>
<td align="center">log, identity, sqrt</td>
</tr>
<tr>
<td align="center">Gamma</td>
<td align="center">inverse, identity, log</td>
</tr>
<tr>
<td align="center">inverse.gaussian</td>
<td align="center">1/mu<sup>2</sup></td>
</tr>
<tr>
<td align="center">quasi</td>
<td align="center">definido pelo usuário</td>
</tr>
</tbody></table>

<h3>Ajuste do modelo</h3>

<pre><code class="r">ajuste_glm &lt;- glm(resposta ~ explicativas, data = dados, family = distribuicao)
</code></pre>

<p>Para ver a lista de distribuições que podem ser passadas ao parâmetro <code>family</code>, rode <code>?family</code> no R.</p>

<p>Outro componente importante em modelos lineares generalizados é a função de ligação. De modo mais geral, o código para ajsutar um MLG fica assim:</p>

<pre><code class="r">ajuste_glm &lt;- glm(resposta ~ explicativas, data = dados, family = distribuicao(link = funcao_de_ligacao))
</code></pre>

<p>Repare que agora existe a parte <code>(link = funcao_de_ligacao)</code> depois do nome da distribuição escolhida. É comum trocar a ligação <code>inversa</code> de uma regressão Gama para uma ligação <code>log</code>, por exemplo. Em R, ficaria:</p>

<pre><code class="r">ajuste_gama &lt;- glm(Y ~ X + I(X^2) + Z, data = dados, family = Gamma(link = &quot;log&quot;))
</code></pre>

<p>Todas as funções úteis para <code>lm()</code> continuam sendo úteis para <code>glm()</code>.</p>

<h3>Exemplo: Regressão logística</h3>

<p>A regressão logística se caracteriza por assumir distribuição binomial à variável resposta. Para exemplificar um ajuste de regressão logística, vamos aproveitar o mesmo banco <code>mtcars</code>, mas agora vamos modelar <code>am</code> em vez de <code>mpg</code>.</p>

<h4>Breve descritiva</h4>

<pre><code class="r">mtcars %&gt;%
  group_by(am) %&gt;%
  summarise(&quot;N&quot; = n(),
            &quot;Missing&quot; = sum(is.na(wt)),
            &quot;Media&quot; = mean(wt),
            &quot;DesvPad&quot; = sd(wt),
            &quot;Minimo&quot; = min(wt),
            &quot;Q1&quot; = quantile(wt, 0.25),
            &quot;Mediana&quot; = quantile(wt, 0.50),
            &quot;Q3&quot; = quantile(wt, 0.75),
            &quot;Maximo&quot; = max(wt)) %&gt;%
  mutate_each(funs(round(.,1)), -am)
</code></pre>

<pre><code>## Error in n(): This function should not be called directly
</code></pre>

<pre><code class="r">ggplot(mtcars) +
  geom_boxplot(aes(x = factor(am), y = wt))
</code></pre>

<p><img src="assets/fig/unnamed-chunk-25-1.png" alt="plot of chunk unnamed-chunk-25"> </p>

<h4>Ajuste</h4>

<pre><code class="r"># Ligação logit
ajuste_glm &lt;- glm(am ~ wt, data = mtcars, family = binomial)
summary(ajuste_glm)
</code></pre>

<pre><code>## 
## Call:
## glm(formula = am ~ wt, family = binomial, data = mtcars)
## 
## Deviance Residuals: 
##         Min           1Q       Median           3Q          Max  
## -2.11400245  -0.53737523  -0.08811338   0.26054663   2.19930809  
## 
## Coefficients:
##              Estimate Std. Error  z value  Pr(&gt;|z|)   
## (Intercept) 12.040370   4.509706  2.66988 0.0075879 **
## wt          -4.023970   1.436416 -2.80140 0.0050882 **
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 43.229733  on 31  degrees of freedom
## Residual deviance: 19.176085  on 30  degrees of freedom
## AIC: 23.176085
## 
## Number of Fisher Scoring iterations: 6
</code></pre>

<pre><code class="r">table(mtcars$am, predict(ajuste_glm) &gt; 0.5)
</code></pre>

<pre><code>##    
##     FALSE TRUE
##   0    18    1
##   1     3   10
</code></pre>

<p>Por padrão, a função de ligação da distribuição <code>binomial</code> é a <code>logit</code>. Se quisermos usar a função <code>probit</code>, precisamos especificar isto no parâmetro <code>family</code>.</p>

<pre><code class="r"># Ligaçao probit
ajuste_glm_probit &lt;- glm(am ~ wt, data = mtcars, family = binomial(link = &quot;probit&quot;))
summary(ajuste_glm_probit)
</code></pre>

<pre><code>## 
## Call:
## glm(formula = am ~ wt, family = binomial(link = &quot;probit&quot;), data = mtcars)
## 
## Deviance Residuals: 
##         Min           1Q       Median           3Q          Max  
## -2.04795707  -0.55217121  -0.05908839   0.25290155   2.18880234  
## 
## Coefficients:
##               Estimate Std. Error  z value  Pr(&gt;|z|)   
## (Intercept)  6.7264081  2.2684171  2.96524 0.0030244 **
## wt          -2.2577631  0.7197233 -3.13699 0.0017069 **
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 43.229733  on 31  degrees of freedom
## Residual deviance: 19.198730  on 30  degrees of freedom
## AIC: 23.19873
## 
## Number of Fisher Scoring iterations: 7
</code></pre>

<p>Gráfico das curvas ajustadas:</p>

<pre><code class="r">ggplot(mtcars, aes(x=wt, y=am)) + 
  geom_point() + 
  stat_smooth(aes(colour = &quot;Logit&quot;), method=&quot;glm&quot;, family=binomial, se=FALSE) +
  stat_smooth(aes(colour = &quot;Probit&quot;), method=&quot;glm&quot;, family=binomial(link = &quot;probit&quot;), se=FALSE) +
  stat_smooth(aes(colour = &quot;Complementar Log-Log&quot;), method=&quot;glm&quot;, family=binomial(link = &quot;cloglog&quot;), se=FALSE) +
  labs(colour = &quot;Função de ligação&quot;)
</code></pre>

<p><img src="assets/fig/unnamed-chunk-28-1.png" alt="plot of chunk unnamed-chunk-28"> </p>

<p>O teste Chi quadrado pode ser mais indicado para regressão logística.</p>

<pre><code class="r">anova(ajuste_glm, test=&quot;Chisq&quot;)
</code></pre>

<pre><code>## Analysis of Deviance Table
## 
## Model: binomial, link: logit
## 
## Response: am
## 
## Terms added sequentially (first to last)
## 
## 
##      Df  Deviance Resid. Df Resid. Dev      Pr(&gt;Chi)    
## NULL                     31  43.229733                  
## wt    1 24.053649        30  19.176085 0.00000093689 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
</code></pre>

<h3>Análise de diagnóstico</h3>

<p>Na página <a href="http://www.ime.usp.br/%7Egiapaula/textoregressao.htm">do professor Gilberto</a> pode-se obter o livro dele sobre GLM e também vários comandos para realizar análises de diagnóstico dos modelos ajustados.</p>

<h2>Modelos mistos</h2>

<p>Quando uma mesma unidade observacional é medida várias vezes em diferentes contextos, temos em mãos um problema de medidas repetidas. Em particular, quando essas medidas são realizadas ao longo do tempo, temos um problema de dados longitudinais.</p>

<p>A dificuldade desses tipos de estudo está no fato de que, como o mesmo indivíduo é observado em vários momentos, nem sempre é razoável considerar essas medidas como independentes. Por exemplo, se estou acompanhando o crescimento da massa de ovelhas ao longo do tempo, esperamos que a ovelha mais &quot;gordinha&quot; tende a ser sempre a mais gordinha.</p>

<p>Para resolver isso, geralmente impomos uma <em>estrutura de correlação</em> para observações de um mesmo indivíduo, e uma maneira de impor essa estrutura de correlação é realizar uma análise com efeitos mistos.</p>

<p>A grande diferença de um modelo de regressão comum e um modelo misto é que parte dos parâmetros são na verdade variáveis aleatórias. Não vamos entrar em detalhe na parte teórica, mas se quiser, dê uma lida no <a href="http://www.ime.usp.br/%7Ejmsinger/Textos/Singer&amp;Nobre&amp;Rocha2012mar.pdf">livro do professor Singer</a>, que está em andamento.</p>

<p>Para ajustar modelos mistos geralmente utilizamos os pacotes <code>nlme</code> e <code>lme4</code>. O pacote <code>nlme</code> faz algumas coisas a mais na parte de modelos não lineares, mas o pacote <code>lme4</code> é muito melhor desenvolvido atualmente e recomendamos seu uso.</p>

<h3>Exemplo: Teste t pareado</h3>

<p>Geralmente utilizamos o teste t pareado quando queremos comparar médias, mas os indivíduos foram medidos em diferentes situações ou momentos.</p>

<p>Vamos ilustrar com os seguintes dados. Na base de dados <code>sleep</code>, temos medido o efeito de duas diferentes drogas aplicadas a 10 indivíduos (as duas drogas foram aplicadas nos 10 indivíduos) no tempo de sono. Queremos verificar se as drogas tiveram efeitos distintos.</p>

<pre><code class="r">sleep %&gt;%
  mutate(group=paste0(&#39;droga_&#39;, group)) %&gt;%
  spread(group, extra)
</code></pre>

<pre><code>##    ID droga_1 droga_2
## 1   1     0.7     1.9
## 2   2    -1.6     0.8
## 3   3    -0.2     1.1
## 4   4    -1.2     0.1
## 5   5    -0.1    -0.1
## 6   6     3.4     4.4
## 7   7     3.7     5.5
## 8   8     0.8     1.6
## 9   9     0.0     4.6
## 10 10     2.0     3.4
</code></pre>

<pre><code class="r">sleep %&gt;%
  ggplot() +
  geom_line(aes(x=group, y=extra, group=ID)) +
  geom_text(aes(x=group, y=extra, label=ID)) +
  theme_bw()
</code></pre>

<p><img src="assets/fig/unnamed-chunk-30-1.png" alt="plot of chunk unnamed-chunk-30"> </p>

<p>Teste t pareado</p>

<pre><code class="r">aux &lt;- sleep %&gt;%
  mutate(group=paste0(&#39;droga_&#39;, group)) %&gt;%
  spread(group, extra)

t.test(aux$droga_1, aux$droga_2, paired=TRUE)
</code></pre>

<pre><code>## 
##  Paired t-test
## 
## data:  aux$droga_1 and aux$droga_2
## t = -4.0621, df = 9, p-value = 0.002833
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -2.4598857633 -0.7001142367
## sample estimates:
## mean of the differences 
##                   -1.58
</code></pre>

<p>Paralelo do modelo misto</p>

<pre><code class="r">library(lme4)
modelo &lt;- lmer(extra ~ group + 1|ID, data=sleep)
</code></pre>

<pre><code>## Error: number of observations (=20) &lt;= number of random effects (=20) for term (group + 1 | ID); the random-effects parameters and the residual variance (or scale parameter) are probably unidentifiable
</code></pre>

<pre><code class="r">summary(modelo)
</code></pre>

<pre><code>## Error in summary(modelo): object &#39;modelo&#39; not found
</code></pre>

<p>A parte <code>1|ID</code> indica que o indivíduo é ID e que estamos incluindo um efeito aleatório para ele.</p>

<h1>Árvore de Decisão</h1>

<p>Outra tipo de modelo muito utilizado que também une simplicidade com eficiência é o de árvore de decisão. No R, seu ajuste é tão simples quanto ajustar um modelo de regressão e possui um conjunto de funções igualmente convenientes para extrair resultados.</p>

<p>Vamos apresentar como ajustar árvore de decisão usando o pacote <code>tree</code>, mas, como tudo no R, existem inúmeros pacotes e jeitos de ajustar uma árvore de decisão (ver este <a href="http://statistical-research.com/a-brief-tour-of-the-trees-and-forests/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=a-brief-tour-of-the-trees-and-forests">link</a> para uma lista interessante de alternativas).</p>

<h2>Ajuste</h2>

<pre><code class="r">library(tree)
ajuste_tree &lt;- tree(factor(am) ~ wt, data = mtcars)
summary(ajuste_tree)
</code></pre>

<pre><code>## 
## Classification tree:
## tree(formula = factor(am) ~ wt, data = mtcars)
## Number of terminal nodes:  5 
## Residual mean deviance:  0.4955481 = 13.3798 / 27 
## Misclassification error rate: 0.09375 = 3 / 32
</code></pre>

<pre><code class="r">plot(ajuste_tree)
text(ajuste_tree, pretty = 0)
</code></pre>

<p><img src="assets/fig/unnamed-chunk-33-1.png" alt="plot of chunk unnamed-chunk-33"> </p>

<p>Tabelas de observado versus predito: comparação entre os modelos logístico e árvore.</p>

<pre><code class="r"># Logistico
table(mtcars$am, predict(ajuste_glm) &gt; 0.5)

# Árvore
table(mtcars$am, predict(ajuste_tree)[,&quot;1&quot;] &gt; 0.5)
</code></pre>

<h2>Cross-validation</h2>

<p>Árvores tendem a &quot;super-ajustar&quot; (<em>overfit</em>) o modelo. Para este problema, <em>cross-validation</em> é uma boa prática. Essa técnica consiste em reservar parte da base separada para depois ser usada como régua para o poder preditivo do modelo.</p>

<p>Para fazer isso é muito fácil com a função <code>cv.tree()</code>. Basta passar seu modelo ajustado para ela:</p>

<pre><code class="r">set.seed(123)
cv_tree &lt;- cv.tree(ajuste_tree)
plot(cv_tree)
</code></pre>

<p><img src="assets/fig/unnamed-chunk-35-1.png" alt="plot of chunk unnamed-chunk-35"> </p>

<p>O gráfico mostra qual tamanho da árvore que apresentou o menor erro de predição. No nosso caso foi tamanho <code>2</code>.</p>

<p>Para recuperar esse ajuste de tamanho <code>2</code>, chamamos a função <code>prune.tree()</code> da seguinte forma:</p>

<pre><code class="r"># seleciona a árvoore com 2 nós
melhor_tree &lt;- prune.tree(ajuste_tree, best = 2)
# Gráfico que representa a árvore `melhor_tree`
plot(melhor_tree)
text(melhor_tree, pretty = 0)
</code></pre>

<p><img src="assets/fig/unnamed-chunk-36-1.png" alt="plot of chunk unnamed-chunk-36"> </p>

<pre><code class="r"># oservado versus predito
table(mtcars$am, predict(melhor_tree)[,&quot;1&quot;] &gt; 0.5)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;ajuste_tree&#39; not found
</code></pre>

<p>O modelo <code>melhor_tree</code> coincidiu com o <code>ajuste_tree</code> (que tinha tamanho <code>5</code>) quanto ao seu desempenho em prever, porém é muito mais simples. De fato ele é mais simples do que qualquer modelo feito até aqui.</p>

<h2>Parâmetros de controle</h2>

<p>Árvores de decisão são ajustadas sob alguns critérios que às vezes precisamos reconfigurar. Por exemplo, no <code>ajuste_tree</code> vimos que havia muito mais galhos do que o necessário. Isso se deveu a critérios de divisão/parada desregulado. </p>

<p>No caso dos objetos <code>tree</code>, temos dois parâmetros importantes: <code>split</code> e <code>control</code>.</p>

<p><strong>split</strong></p>

<p>O parâmetro <code>split</code> define qual o critério para decidir se divide o &quot;galho&quot; ou não. Por padrão, a função utiliza o critério &quot;deviance&quot;, que tem a mesma definição do MLG. Uma segunda opção seria <strong>Gini</strong>.</p>

<p><strong>control</strong></p>

<p>O parâmetro <code>control</code> recebe um objeto retornado pela função <code>tree.control()</code>.</p>

<p>Esta função permite você configurar:</p>

<ul>
<li><code>nobs</code> Número de observações na base de treino. Isso será efetivo no <code>cv.tree()</code>, quando uma base de treino e outra de teste é utilizada para calcular o erro de predição por meio de <em>cross-validation</em>.</li>
<li><code>mincut</code> Número mínimo de observações a serem incluídas em cada nó.</li>
<li><code>minsize</code> O menor tamanho de nó permitido.</li>
<li><code>mindev</code> Fração mínima do deviance do nó raiz.</li>
</ul>

<p>Como passar à função:</p>

<pre><code class="r">controles &lt;- tree.control(nobs = 32, mincut = 10)
ajuste_tree &lt;- ajuste_tree &lt;- tree(factor(am) ~ wt, data = mtcars, control = controles)
plot(ajuste_tree);text(ajuste_tree, pretty = 0)
</code></pre>

<p><img src="assets/fig/unnamed-chunk-37-1.png" alt="plot of chunk unnamed-chunk-37"> </p>

<h1>Análise multivariada</h1>

<h2>Análise de Agrupamento</h2>

<p>Análise de agrupamento geralmente é uma ótima maneira de realizar estudos preliminares em uma base de dados, e algumas vezes pode trazer resultados muito úteis.</p>

<p>Como o próprio nome diz, geralmente a análise de agrupamento serve para formar grupos de indivíduos a partir da comparação das suas medidas em relação à diversas variáveis. Não confunda aqui com árvores de decisão, pois nesse caso não há uma variável &quot;resposta&quot;.</p>

<p>Existem dois tipos principais de análise de agrupamento: <em>hierárquico</em> e <em>k-means</em>. </p>

<h3>K-means</h3>

<p>No modelo k-means, selecionamos previamente o número de grupos e o modelo calcula, com base em algum critério, qual a melhor forma de alocar os indivíduos nesses grupos. </p>

<p>Para ajustar essa análise utilizaremos a função <code>kmeans</code> do pacote <code>stats</code>. Existem mais pacotes que fazem essa análise no R.</p>

<pre><code class="r">kms &lt;- kmeans(mtcars, centers=2)
kms
</code></pre>

<pre><code>## K-means clustering with 2 clusters of sizes 18, 14
## 
## Cluster means:
##           mpg         cyl        disp           hp        drat          wt        qsec           vs           am        gear        carb
## 1 23.97222222 4.777777778 135.5388889  98.05555556 3.882222222 2.609055556 18.68611111 0.7777777778 0.6111111111 4.000000000 2.277777778
## 2 15.10000000 8.000000000 353.1000000 209.21428571 3.229285714 3.999214286 16.77214286 0.0000000000 0.1428571429 3.285714286 3.500000000
## 
## Clustering vector:
##           Mazda RX4       Mazda RX4 Wag          Datsun 710      Hornet 4 Drive   Hornet Sportabout             Valiant          Duster 360 
##                   1                   1                   1                   1                   2                   1                   2 
##           Merc 240D            Merc 230            Merc 280           Merc 280C          Merc 450SE          Merc 450SL         Merc 450SLC 
##                   1                   1                   1                   1                   2                   2                   2 
##  Cadillac Fleetwood Lincoln Continental   Chrysler Imperial            Fiat 128         Honda Civic      Toyota Corolla       Toyota Corona 
##                   2                   2                   2                   1                   1                   1                   1 
##    Dodge Challenger         AMC Javelin          Camaro Z28    Pontiac Firebird           Fiat X1-9       Porsche 914-2        Lotus Europa 
##                   2                   2                   2                   2                   1                   1                   1 
##      Ford Pantera L        Ferrari Dino       Maserati Bora          Volvo 142E 
##                   2                   1                   2                   1 
## 
## Within cluster sum of squares by cluster:
## [1] 58920.54393 93643.90394
##  (between_SS / total_SS =  75.5 %)
## 
## Available components:
## 
## [1] &quot;cluster&quot;      &quot;centers&quot;      &quot;totss&quot;        &quot;withinss&quot;     &quot;tot.withinss&quot; &quot;betweenss&quot;    &quot;size&quot;         &quot;iter&quot;         &quot;ifault&quot;
</code></pre>

<h3>Hierárquico</h3>

<p>No modelo hierárquico, contudo, não selecionamos previamente o número de grupos, e o resultado da análise é um gráfico chamado <em>dendrograma</em>, que cria uma ordem de agrupamento dos indivíduos, desde o nível mais fragmentado (número de grupos igual ao número de indivíduos) até um agrupamento único.</p>

<p>Para ajustar o modelo hierárquico, utilizaremos a função <code>hclust</code>, do pacote <code>stats</code>. Existem vários métodos para ordenação dos ordenamentos. Utilizaremos aqui o método <code>ward.D</code>.</p>

<p>Diferentemente do método K-means, os métodos hierárquicos partem de uma matriz de distâncias ou, mais genericamente, matriz de dissimilaridades. A matrix de distâncias é uma matriz <code>d</code> com <code>dim(d) = c(n, n)</code>, onde <code>n</code> é o número de indivíduos. Geralmente é uma matriz simétrica, e na diagonal vale zero. </p>

<pre><code class="r">d &lt;- dist(mtcars) # calcula matriz de distâncias euclidianas.
str(d)
</code></pre>

<pre><code>## Class &#39;dist&#39;  atomic [1:496] 0.615 54.909 98.113 210.337 65.472 ...
##   ..- attr(*, &quot;Size&quot;)= int 32
##   ..- attr(*, &quot;Labels&quot;)= chr [1:32] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; &quot;Hornet 4 Drive&quot; ...
##   ..- attr(*, &quot;Diag&quot;)= logi FALSE
##   ..- attr(*, &quot;Upper&quot;)= logi FALSE
##   ..- attr(*, &quot;method&quot;)= chr &quot;euclidean&quot;
##   ..- attr(*, &quot;call&quot;)= language dist(x = mtcars)
</code></pre>

<pre><code class="r">hc &lt;- hclust(d, method=&#39;ward.D&#39;)
hc
</code></pre>

<pre><code>## 
## Call:
## hclust(d = d, method = &quot;ward.D&quot;)
## 
## Cluster method   : ward.D 
## Distance         : euclidean 
## Number of objects: 32
</code></pre>

<pre><code class="r">plot(hc)
</code></pre>

<p><img src="assets/fig/unnamed-chunk-39-1.png" alt="plot of chunk unnamed-chunk-39"> </p>

<p>No método hierárquico, portanto, geralmente precisamos tomar 2 decisões para rodar a análise e construir o dendrograma: i) o método para obtenção da matriz de distâncias e o método para ordenação das aglomerações.</p>

<p><strong>OBS:</strong> Na análise de agrupamento, muitas vezes a escala das variáveis faz diferença, e variáveis que assumem valores muito altos podem ter uma influência maior do que outras no resultado da análise. Por isso, muitas vezes temos interesse em re-escalar as variáveis, geralmente subtraindo a média e dividindo pelo desvio padrão (normalização). Para isso, veja <code>?scale</code>.</p>

<h2>Análise Fatorial</h2>

<p>Outra análise multivariada muito comum é a <em>análise fatorial</em>. Nesse tipo de estudo, geralmente estamos interessados em obter combinações de variáveis que estejam associadas a alguma variável latente não observável. Em palavras mais simples, estamos interessados em obter alguns <em>fatores</em> que expliquem a variabilidade dos nossos dados, e depois interpretar esses fatores de alguma forma.</p>

<p>Para realizar análise fatorial, vamos utilizar a função <code>factanal</code> do pacote <code>stats</code>. Essa função realiza análise fatorial usando método de máxima verossimilhança. Podemos utilizar outros métodos, como decomposição espectral (autovalor e autovetor), geralmente utilizada em <em>análise de componentes principais</em>.</p>

<pre><code class="r">fa &lt;- factanal(mtcars, factors=3, rotation=&#39;none&#39;)
fa
</code></pre>

<pre><code>## 
## Call:
## factanal(x = mtcars, factors = 3, rotation = &quot;none&quot;)
## 
## Uniquenesses:
##   mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb 
## 0.135 0.055 0.090 0.127 0.290 0.060 0.051 0.223 0.208 0.125 0.158 
## 
## Loadings:
##      Factor1 Factor2 Factor3
## mpg  -0.910   0.137  -0.136 
## cyl   0.962          -0.135 
## disp  0.937  -0.174         
## hp    0.875   0.292   0.147 
## drat -0.689   0.453   0.175 
## wt    0.858  -0.382   0.242 
## qsec -0.591  -0.754   0.177 
## vs   -0.809  -0.309   0.164 
## am   -0.522   0.719         
## gear -0.459   0.729   0.365 
## carb  0.594   0.517   0.471 
## 
##                Factor1 Factor2 Factor3
## SS loadings      6.448   2.465   0.565
## Proportion Var   0.586   0.224   0.051
## Cumulative Var   0.586   0.810   0.862
## 
## Test of the hypothesis that 3 factors are sufficient.
## The chi square statistic is 30.53 on 25 degrees of freedom.
## The p-value is 0.205
</code></pre>

<pre><code class="r">pesos &lt;- fa$loadings[,1:3] %&gt;% data.frame %&gt;% mutate(nomes=rownames(.))
ggplot(pesos, aes(x=Factor1, y=Factor2)) +
  geom_text(aes(label=nomes)) +
  geom_vline(xintercept=0) +
  geom_hline(yintercept=0) +
  coord_equal()
</code></pre>

<p><img src="assets/fig/unnamed-chunk-40-1.png" alt="plot of chunk unnamed-chunk-40"> </p>

<p>Na análise fatorial, podemos realizar também a <em>rotação</em> dos fatores obtidos, para tentar isolar os componentes de cada fator, facilitando a interpretação dos fatores. O método mais comum para realizar a rotação é pelo método <code>varimax</code>.</p>

<pre><code class="r">fa &lt;- factanal(mtcars, factors=3, rotation=&#39;varimax&#39;)

pesos &lt;- fa$loadings[,1:3] %&gt;% data.frame %&gt;% mutate(nomes=rownames(.))
ggplot(pesos, aes(x=Factor1, y=Factor2)) +
  geom_text(aes(label=nomes)) +
  geom_vline(xintercept=0) +
  geom_hline(yintercept=0) +
  coord_equal()
</code></pre>

<p><img src="assets/fig/unnamed-chunk-41-1.png" alt="plot of chunk unnamed-chunk-41"> </p>

<p>A análise fatorial tem muito mais detalhes que foram omitidos. Para um tutorial rápido, ver no <a href="http://www.statmethods.net/advstats/factor.html">Quick-R</a>.</p>

<h2>Análise de correspondência múltipla</h2>

<p>Quando temos uma base de dados com muitas variáveis categóticas, geralmente é difícil analisá-las em conjunto, e muitas vezes ficamos fazendo um monte de tabelas de contingência, o que pode ser doloroso.</p>

<p>A análise de correspondência múltipla pode ser considerada como uma espécie de <em>análise de componentes principais</em> para dados categóricos. Ela serve para dar uma &quot;visão geral&quot; da base de dados, reduzindo a dimensionalidade da base e visualizando as associações das variáveis em apenas um gráfico.</p>

<p>Para realizar a análise, vamos utilizar a função <code>MCA</code> do pacote <code>FactoMineR</code>. Esse pacote, aliás, contém diversos métodos para realização de análises multivariadas.</p>

<p>Como base de dados, utilizaremos <code>tea</code> do pacote <code>FactoMiner</code>, que é basicamente um questionário aplicado a 300 pessoas sobre como elas tomam chá.</p>

<pre><code class="r">library(FactoMiner)
</code></pre>

<pre><code>## Error in library(FactoMiner): there is no package called &#39;FactoMiner&#39;
</code></pre>

<pre><code class="r">data(tea)

# Vamos trabalhas só com essas colunas
newtea &lt;- tea %&gt;% select(Tea, How, how, sugar, where, always) %&gt;% tbl_df
</code></pre>

<pre><code>## Error in select(., Tea, How, how, sugar, where, always): unused arguments (Tea, How, how, sugar, where, always)
</code></pre>

<pre><code class="r">newtea
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;newtea&#39; not found
</code></pre>

<pre><code class="r"># numero de niveis de cada variavel
cats &lt;- newtea %&gt;% summarise_each(funs(length(unique(.))))
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;newtea&#39; not found
</code></pre>

<pre><code class="r">cats
</code></pre>

<pre><code>##     Sex Bwt  Hwt
## 1     F 2.0  7.0
## 2     F 2.0  7.4
## 3     F 2.0  9.5
## 4     F 2.1  7.2
## 5     F 2.1  7.3
## 6     F 2.1  7.6
## 7     F 2.1  8.1
## 8     F 2.1  8.2
## 9     F 2.1  8.3
## 10    F 2.1  8.5
## 11    F 2.1  8.7
## 12    F 2.1  9.8
## 13    F 2.2  7.1
## 14    F 2.2  8.7
## 15    F 2.2  9.1
## 16    F 2.2  9.7
## 17    F 2.2 10.9
## 18    F 2.2 11.0
## 19    F 2.3  7.3
## 20    F 2.3  7.9
## 21    F 2.3  8.4
## 22    F 2.3  9.0
## 23    F 2.3  9.0
## 24    F 2.3  9.5
## 25    F 2.3  9.6
## 26    F 2.3  9.7
## 27    F 2.3 10.1
## 28    F 2.3 10.1
## 29    F 2.3 10.6
## 30    F 2.3 11.2
## 31    F 2.4  6.3
## 32    F 2.4  8.7
## 33    F 2.4  8.8
## 34    F 2.4 10.2
## 35    F 2.5  9.0
## 36    F 2.5 10.9
## 37    F 2.6  8.7
## 38    F 2.6 10.1
## 39    F 2.6 10.1
## 40    F 2.7  8.5
## 41    F 2.7 10.2
## 42    F 2.7 10.8
## 43    F 2.9  9.9
## 44    F 2.9 10.1
## 45    F 2.9 10.1
## 46    F 3.0 10.6
## 47    F 3.0 13.0
## 48    M 2.0  6.5
## 49    M 2.0  6.5
## 50    M 2.1 10.1
## 51    M 2.2  7.2
## 52    M 2.2  7.6
## 53    M 2.2  7.9
## 54    M 2.2  8.5
## 55    M 2.2  9.1
## 56    M 2.2  9.6
## 57    M 2.2  9.6
## 58    M 2.2 10.7
## 59    M 2.3  9.6
## 60    M 2.4  7.3
## 61    M 2.4  7.9
## 62    M 2.4  7.9
## 63    M 2.4  9.1
## 64    M 2.4  9.3
## 65    M 2.5  7.9
## 66    M 2.5  8.6
## 67    M 2.5  8.8
## 68    M 2.5  8.8
## 69    M 2.5  9.3
## 70    M 2.5 11.0
## 71    M 2.5 12.7
## 72    M 2.5 12.7
## 73    M 2.6  7.7
## 74    M 2.6  8.3
## 75    M 2.6  9.4
## 76    M 2.6  9.4
## 77    M 2.6 10.5
## 78    M 2.6 11.5
## 79    M 2.7  8.0
## 80    M 2.7  9.0
## 81    M 2.7  9.6
## 82    M 2.7  9.6
## 83    M 2.7  9.8
## 84    M 2.7 10.4
## 85    M 2.7 11.1
## 86    M 2.7 12.0
## 87    M 2.7 12.5
## 88    M 2.8  9.1
## 89    M 2.8 10.0
## 90    M 2.8 10.2
## 91    M 2.8 11.4
## 92    M 2.8 12.0
## 93    M 2.8 13.3
## 94    M 2.8 13.5
## 95    M 2.9  9.4
## 96    M 2.9 10.1
## 97    M 2.9 10.6
## 98    M 2.9 11.3
## 99    M 2.9 11.8
## 100   M 3.0 10.0
## 101   M 3.0 10.4
## 102   M 3.0 10.6
## 103   M 3.0 11.6
## 104   M 3.0 12.2
## 105   M 3.0 12.4
## 106   M 3.0 12.7
## 107   M 3.0 13.3
## 108   M 3.0 13.8
## 109   M 3.1  9.9
## 110   M 3.1 11.5
## 111   M 3.1 12.1
## 112   M 3.1 12.5
## 113   M 3.1 13.0
## 114   M 3.1 14.3
## 115   M 3.2 11.6
## 116   M 3.2 11.9
## 117   M 3.2 12.3
## 118   M 3.2 13.0
## 119   M 3.2 13.5
## 120   M 3.2 13.6
## 121   M 3.3 11.5
## 122   M 3.3 12.0
## 123   M 3.3 14.1
## 124   M 3.3 14.9
## 125   M 3.3 15.4
## 126   M 3.4 11.2
## 127   M 3.4 12.2
## 128   M 3.4 12.4
## 129   M 3.4 12.8
## 130   M 3.4 14.4
## 131   M 3.5 11.7
## 132   M 3.5 12.9
## 133   M 3.5 15.6
## 134   M 3.5 15.7
## 135   M 3.5 17.2
## 136   M 3.6 11.8
## 137   M 3.6 13.3
## 138   M 3.6 14.8
## 139   M 3.6 15.0
## 140   M 3.7 11.0
## 141   M 3.8 14.8
## 142   M 3.8 16.8
## 143   M 3.9 14.4
## 144   M 3.9 20.5
</code></pre>

<pre><code class="r"># MCA
mca &lt;- MCA(newtea, graph = FALSE)
</code></pre>

<pre><code>## Error in as.data.frame(X): object &#39;newtea&#39; not found
</code></pre>

<pre><code class="r"># Coordenadas das variaveis
mca1_vars_df &lt;- data.frame(mca$var$coord, variavel=rep(names(cats), cats), stringsAsFactors=F) %&gt;%
  mutate(rnames=row.names(.))
</code></pre>

<pre><code>## Error in mca$var: object of type &#39;closure&#39; is not subsettable
</code></pre>

<pre><code class="r"># Coordenadas das observacoes
mca1_obs_df &lt;- data.frame(mca$ind$coord)
</code></pre>

<pre><code>## Error in mca$ind: object of type &#39;closure&#39; is not subsettable
</code></pre>

<pre><code class="r"># Um gráfico bonito
ggplot() +
  geom_hline(yintercept = 0, colour = &quot;gray70&quot;) +
  geom_vline(xintercept = 0, colour = &quot;gray70&quot;) +
  geom_text(aes(x=Dim.1, y=Dim.2, colour=variavel, label=rnames), data=mca1_vars_df) +
  geom_point(aes(x=Dim.1, y=Dim.2), colour = &quot;gray50&quot;, alpha = 0.7, data=mca1_obs_df) +
  geom_density2d(aes(x=Dim.1, y=Dim.2), colour = &quot;gray80&quot;, data=mca1_obs_df)
</code></pre>

<pre><code>## Error in do.call(&quot;layer&quot;, list(mapping = mapping, data = data, stat = stat, : object &#39;mca1_vars_df&#39; not found
</code></pre>

<p>O gráfico mostra várias coisas de uma vez só. </p>

<ul>
<li>A dispersão mostra as dimensões calculadas pelo método de análise de correspondência múltipla. </li>
<li>As curvas de nível mostram a concentração dos dados.</li>
<li>Os textos são os níveis das variáveis, identificados pela cor.</li>
</ul>

<p>Nesse caso, verificamos, por exemplo, que pode existir uma associação entre <code>how</code> e <code>where</code>, pois &quot;tea bag&quot; está muito próximo de &quot;chain store&quot;.</p>

<p><strong>OBS:</strong> Baseado no excelente post de <a href="http://gastonsanchez.com/blog/how-to/2012/10/13/MCA-in-R.html">Gaston Sanchez</a>.</p>

<h1>Demais tópicos</h1>

<ul>
<li>Séries temporais</li>
<li>Dados categorizados</li>
<li>GAM/GAMLSS</li>
<li>Inferência Bayesiana</li>
<li>Processos estocásticos</li>
<li>Reamostragem</li>
<li>Muito mais!</li>
</ul>

<h1>Referências</h1>

<p><a href="http://www-bcf.usc.edu/%7Egareth/ISL/ISLR%20First%20Printing.pdf">http://www-bcf.usc.edu/~gareth/ISL/ISLR%20First%20Printing.pdf</a></p>

<p><a href="http://web.stanford.edu/%7Ehastie/local.ftp/Springer/OLD/ESLII_print4.pdf">http://web.stanford.edu/~hastie/local.ftp/Springer/OLD/ESLII_print4.pdf</a></p>

<p><a href="http://www.ime.usp.br/%7Egiapaula/texto_2013.pdf">http://www.ime.usp.br/~giapaula/texto_2013.pdf</a></p>

<p>Colosimo, E.A. e Giolo, S.R. (2006) Análise de sobrevivência aplicada. ABE - Projeto Fisher, Blucher.</p>

<p><a href="http://adv-r.had.co.nz/Functions.html">http://adv-r.had.co.nz/Functions.html</a></p>

<p><a href="http://www.burns-stat.com/pages/Tutor/R_inferno.pdf">http://www.burns-stat.com/pages/Tutor/R_inferno.pdf</a></p>

              <div id="disqus_thread"></div>
            </li>
          </ol>
          <div class="pagination">
            <ul>
              <li><a href="http://curso-r.github.io">&#171; Back Home</a></li>
            </ul>
          </div> 
        </div>
			</div>
		</div>
  </div>
</body>
  <script src='../libraries/frameworks/purus/js/bootstrap.min.js'></script>
  <script>
      var disqus_developer = 1;
      var disqus_shortname = 'curso-r'; 
      // required: replace example with your forum shortname
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); 
          dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || 
           document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <!-- MathJax: Fall back to local if CDN offline but local image fonts are not supported (saves >100MB) -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true
      }
    });
  </script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- <script src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script> -->
  <script>window.MathJax || document.write('<script type="text/x-mathjax-config">MathJax.Hub.Config({"HTML-CSS":{imageFont:null}});<\/script><script src="../libraries/widgets/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"><\/script>')
</script>
<!-- Google Prettify -->
  <script src="http://cdnjs.cloudflare.com/ajax/libs/prettify/188.0.0/prettify.js"></script>
  <script src='../libraries/highlighters/prettify/js/lang-r.js'></script>
  <script>
    var pres = document.getElementsByTagName("pre");
    for (var i=0; i < pres.length; ++i) {
      pres[i].className = "prettyprint linenums";
    }
    prettyPrint();
  </script>
  <!-- End Google Prettify --> 
  </html>